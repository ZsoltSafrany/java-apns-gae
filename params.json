{"name":"java-apns-gae","tagline":"Java APNS library that works on Google App Engine","body":"# Introduction\r\n\r\nThis is a Java Apple Push Notification Service library that works on Google App Engine. It was designed to work (and be used) on Google App Engine but it doesn't have any GAE specific dependencies; you may use it anywhere where Java runs. \r\n\r\n\r\n```java\r\nnew PushNotification()\r\n  .setAlert(\"You got your emails.\")\r\n  .setBadge(9)\r\n  .setSound(\"bingbong.aiff\")\r\n  .setDeviceTokens(\"777d2ac490a17bb1d4c8a6ec7c50d4b1b9a36499acd45bf5fcac103cde038eff\");\r\n```\r\n\r\nThe library works on Java 7 and above. \r\n\r\n# Features\r\n\r\n## Create a push notification  \r\n\r\n### Create a simple push notification\r\n\r\n```java\r\nnew PushNotification()\r\n  .setAlert(\"You got your emails.\")\r\n  .setBadge(9)\r\n  .setSound(\"bingbong.aiff\")\r\n  .setDeviceTokens(\"777d2ac490a17bb1d4c8a6ec7c50d4b1b9a36499acd45bf5fcac103cde038eff\");\r\n```\r\n\r\nNote, that if you don't set a `Badge` value then the badge won't change. To remove the badge, set the value to 0.\r\n\r\nYou can send the same push notification to more than one device. The overloaded methods you can use are:\r\n```java\r\n.setDeviceTokens(String... deviceTokens)\r\n.setDeviceTokens(Collection<String> deviceTokens)\r\n```\r\n\r\n### Create with complex alert\r\n\r\n```java\r\nComplexAlert complexAlert = new ComplexAlert()\r\n  .setBody(\"Bob wants to play poker\")\r\n  .setActionLocKey(\"PLAY\")\r\n  .setLocKey(\"GAME_PLAY_REQUEST_FORMAT\")\r\n  .setLocArgs(\"Jenna\", \"Frank\")\r\n  .setLaunchImage(\"AllIn.png\");\r\nnew PushNotification().setComplexAlert(complexAlert);\r\n```\r\n\r\nFor a description of these properties check out the [Local and Push Notification Programming Guide](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html). \r\n\r\n### Create with custom payload\r\n\r\n```java\r\nnew PushNotification()\r\n  .setAlert(\"This is a notification with custom payload.\")\r\n  .setDeviceTokens(\"777d2ac490a17bb1d4c8a6ec7c50d4b1b9a36499acd45bf5fcac103cde038eff\")\r\n  .setCustomPayload(\"acme1\", \"bar\");\r\n  .setCustomPayload(\"acme2\", 42);\r\n```\r\n\r\nYou should not include customer information (or any sensitive data) as custom payload data. \r\n\r\nRemember, that the maximum size allowed for a notification payload is 256 bytes. `PushNotificationService.send()` will throw a `PayloadException` when you try to pass a `PushNotification` that results in a payload that exceeds this limit.\r\n\r\n## Send a push notification\r\n\r\nTo send a push notification you will need two more things: a `PushNotificationService` and an `ApnsConnection`. If you have both you just say:\r\n\r\n```java\r\nPushNotification pn = ...; // push notification you created\r\nPushNotificationService pns = ...; // obtain one\r\nApnsConnection connection = ...; // obtain one\r\npns.send(pn, connection);\r\n```\r\n\r\n### Obtain a PushNotificationService\r\n\r\nThis is quite simple; use the provided default implementation:\r\n\r\n```java\r\nPushNotificationService pns = new DefaultPushNotificationService();\r\n```\r\n\r\n### Obtain an ApnsConnection\r\n\r\nYou can create `ApnsConnection` instances with an `ApnsConnectionFactory`. Use the provided default factory implementation `DefaultApnsConnectionFactory`: \r\n\r\n```java\r\nDefaultApnsConnectionFactory.Builder builder = DefaultApnsConnectionFactory.Builder.get();\r\nif (usingProductionApns) {\r\n  KeyStoreProvider ksp = new ClassPathResourceKeyStoreProvider(\"apns/apns_certificates_production.p12\", KeyStoreType.PKCS12, KEYSTORE_PASSWORD);\r\n  builder.setProductionKeyStoreProvider(ksp);\r\n} else {\r\n  KeyStoreProvider ksp = new ClassPathResourceKeyStoreProvider(\"apns/apns_certificates_sandbox.p12\", KeyStoreType.PKCS12, KEYSTORE_PASSWORD);\r\n  builder.setSandboxKeyStoreProvider(ksp);\r\n}\r\nApnsConnectionFactory acf = builder.build();\r\n\r\nApnsConnection connection = acf.openPushConnection();\r\n```\r\n\r\nEach call to `openPushConnection()` will open and create a new connection to APNS.\r\n\r\nThe example uses keystores that are located on the classpath. In a usual Maven project, these two example keystores are located at `src/main/resources/apns/apns_certificates_{production|sandbox}.p12`. If you want to load the keystores yourself then use class `WrapperKeyStoreProvider` instead:\r\n\r\n```java\r\nKeyStore ks = ...; // keystore you loaded manually\r\nKeyStoreProvider ksp = new WrapperKeyStoreProvider(ks, KEYSTORE_PASSWORD);\r\nbuilder.setProductionKeyStoreProvider(ksp);\r\n```\r\n\r\n## Read the Feedback Service\r\n\r\nThe Apple Push Notification Service includes a feedback service to give you information about failed push notifications.\r\n\r\nTo read the feedback service you will need two things: a `FeedbackService` and an `ApnsConnection`. If you have both you just say:\r\n\r\n```java\r\nApnsConnectionFactory acf = ...; // obtain one\r\nApnsConnection connection = acf.openFeedbackConnection();\r\nFeedbackService fs = new DefaultFeedbackService();\r\nList<FailedDeviceToken> failedTokens = fs.read(connection);\r\n\r\nfor (FailedDeviceToken failedToken : failedTokens) {\r\n  failedToken.getFailTimestamp();\r\n  failedToken.getDeviceToken();\r\n}\r\n```\r\n\r\nNote that this time the `ApnsConnection` is obtained with `openFeedbackConnection()` instead of `openPushConnection()` (as the feedback service listens on a different address than the push service).\r\n\r\nUse `getFailTimestamp()` to verify that the device token hasn’t been reregistered since the feedback entry was generated. For each device that has not been reregistered, stop sending notifications. \r\n\r\nThe feedback service’s list is cleared after you read it. Each time you call `FeedbackService.read()`, the information it returns lists only the failures that have happened since the last `read()`.\r\n\r\n## Test your code\r\n\r\nYou can test your code that uses this library quite easily as `ApnsConnection`, `ApnsConnectionFactory`, `PushNotificationService` and `FeedbackService` are all interfaces. You may create whatever mock objects you need for testing. However, the library includes some convenient mock implementations:\r\n\r\n### MockApnsConnectionFactory\r\n\r\nIt returns mock connections. Use this to create `ApnsConnection` instances for the following two classes.\r\n\r\n### MockPushNotificationService\r\n\r\n```java\r\nMockPushNotificationService mpns = new MockPushNotificationService();\r\n\r\n// code under test\r\nPushNotificationService pns = mpns;\r\npns.send(pushNotification, connection);\r\n\r\n// assertions\r\nString deviceToken = \"777d2ac490a17bb1d4c8a6ec7c50d4b1b9a36499acd45bf5fcac103cde038eff\";\r\nassertTrue(mpns.pushWasSentTo(deviceToken));\r\nPushNotification pn = mpns.getLastPushSentToDevice(deviceToken); \r\n```\r\n\r\nThis way you can assert that a push notification was sent; you can make sure that your code under test did send a push notification to a specific device token.\r\n\r\nWith `getLastPushSentToDevice()` you can also obtain the push notification itself that was \"sent\" (passed to the mock implementation).\r\n\r\n### MockFeedbackService\r\n\r\n```java\r\nMockFeedbackService mfs = new MockFeedbackService();\r\nmfs.add(\"777d2ac490a17bb1d4c8a6ec7c50d4b1b9a36499acd45bf5fcac103cde038eff\");\r\n\r\nFeedbackService fs = mfs;\r\nList<FailedDeviceToken> failedTokens = rs.read(connection);\r\n```\r\n\r\nThis way you can simulate the feedback service giving back a list of failed tokens; you can make sure, for instance, that your code under test does delete device tokens (returned by the feedback service) from your database.\r\n\r\nLike in case of the real feedback service, the list of failed tokens are cleared after you call `read()`.\r\n\r\n## Make it work on App Engine\r\n\r\nSo far everything was independent from App Engine. In this section you'll see how to use the library efficiently on GAE.\r\n\r\n### Sockets; the 2 minutes problem\r\n\r\nSockets may be reclaimed after 2 minutes of inactivity on App Engine. See [Limitations and restrictions](https://developers.google.com/appengine/docs/java/sockets/).\r\n\r\nAnd the problem is you can't keep a socket connected to APNS artifically open; without sending actual push notifications. The only way to keep it open is to send some arbitrary data/bytes but that would result in an immediate closure of the socket; APNS closes the connection as soon as it detects something that does not conform to the protocol, i.e. something that is not an actual push notification.\r\n\r\n#### `SO_KEEPALIVE`\r\n\r\n\r\nWhat about `SO_KEEPALIVE`? App Engine explicitly says it is supported. I think it just means it won't throw an exception when you call `Socket.setKeepAlive(true)`; calls wanted to set socket options raised Not Implemented exceptions before. Even if you enable keep-alive your socket will be reclaimed (closed) if you don't send something for more than 2 minutes; at least on App Engine as of 08.22.2014. \r\n\r\nActually, it's not a big surprise. [RFC1122](http://tools.ietf.org/html/rfc1122#page-101) that specifies TCP Keep Alive explicitly states that TCP Keep Alives are not to be sent more than once every two hours, and then, it is only necessary if there was no other traffic. Although, it also says that this interval must be also configurable, there is no API on `java.net.Socket` you could use to configure that (most probably because it's highly OS dependent) and I doubt it would be set to 2 minutes on App Engine. \r\n\r\n### `SO_TIMEOUT`\r\n\r\n\r\nWhat about `SO_TIMEOUT`? It is for something completely else. The javadoc of `Socket.setSoTimeout()` states:\r\n\r\n```\r\nEnable/disable SO_TIMEOUT with the specified timeout, in milliseconds. With this \r\noption set to a non-zero timeout, a read() call on the InputStream associated \r\nwith this Socket will block for only this amount of time. If the timeout expires, \r\na java.net.SocketTimeoutException is raised, though the Socket is still valid. \r\nThe option must be enabled prior to entering the blocking operation to have effect. \r\nThe timeout must be > 0. A timeout of zero is interpreted as an infinite timeout.\r\n```\r\n\r\nThat is, when `read()` is blocking for too long because there's nothing to read you can say \"ok, I don't want to wait (block) anymore; let's do something else instead\". It's not going to help with our \"2 minutes\" problem.\r\n\r\n### What then?\r\n\r\nThe only way you can work around this problem is this: detect when a connection is reclaimed/closed then throw it away and open a new connection. And this library supports exactly that.\r\n\r\n```java\r\n// do this only once\r\nApnsConnectionFactory acf = ...; // obtain one\r\nPushNotificationService pns = ...; // obtain one\r\n\r\n// do this every time you want to send a push notification\r\nPushNotification pn = ...; // create push notification\r\nApnsConnection connection = ...; // already opened and cached connection\r\ntry {\r\n  pns.send(pn, connection);\r\n} catch (CannotUseConnectionException e) {\r\n  // throw away connection (i.e. just simply lose all your references to the object) \r\n  // and open new connection\r\n  connection = acf.openPushConnection();\r\n  pns.send(pn, connection); // it should work now; we are using a just-opened connection\r\n  cacheConnection(connection); // hoping you can successfuly reuse it the next time\r\n}\r\n\r\n```\r\n\r\nIt is possible that the socket is not reclaimed but you still receive a `CannotUseConnectionException`. This can happen because of any transient issue (e.g. networking, App Engine, APNS) and you should throw away the connection just the very same way; should happen very rarely, though.\r\n\r\n### More detailed App Engine example\r\n\r\nNow it's clear that reusing, throwing away and opening new connections is the way to go. Let me show you a more detailed example of how the library could be used on App Engine. I will assume that you are familiar with App Engine itself.\r\n\r\nLet's give an overview of the example: we'll a have separate (basic-scaling) App Engine module (let's call it `apns`) that will be doing only one thing, sending push notifications to APNS. We will never send push notficiations in the current, user-initiated request; we will have a push queue for enqueuing tasks responsible for sending push notifications. Tasks will be executed in the `apns` module; tasks can be enqueued from anywhere. Our `apns` module will have some (let's say `5`) concurrent socket connections (well, `ApnsConnection` instances) that the module will keep in a pool for reuse. \r\n\r\nSo, let's see how to do that.\r\n\r\n#### Separate `apns` module\r\n\r\nLet's create a separate module. Its `appengine-web.xml` file looks like this:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<appengine-web-app xmlns=\"http://appengine.google.com/ns/1.0\">\r\n    <application>your-app-name</application>\r\n    <module>apns</module>\r\n    <version>your-version</version>\r\n    <threadsafe>true</threadsafe>\r\n    <instance-class>B1</instance-class>\r\n    <basic-scaling>\r\n        <max-instances>1</max-instances>\r\n        <idle-timeout>10m</idle-timeout>\r\n    </basic-scaling>\r\n\r\n    <system-properties>\r\n        <property name=\"java.util.logging.config.file\" value=\"WEB-INF/logging.properties\"/>\r\n    </system-properties>\r\n</appengine-web-app>\r\n```\r\n\r\nIt says it's a `basic-scaling` module with the cheapest instance. We use `basic-scaling` because this way (unlike `automatic-scaling`) we can limit the number of instances and thus the number of concurrent APNS connections, plus (unlike `manual-scaling`) we don't need to bother about instance startup/shutdown as idle instances will be shut down (saving us money).\r\n\r\nIn our example, we set the limit of maximum instances to `1` and that one instance will be shut down if it's idle for more than `10` minutes.\r\n\r\n#### Push queue \r\n\r\nLet's define the queue responsible for sending push notifications. Let's add the queue definition to queue.xml:\r\n\r\n```xml\r\n<queue-entries>\r\n  \r\n  [...]\r\n\r\n  <queue>\r\n    <name>apns</name>\r\n    <rate>20/s</rate>\r\n    <bucket-size>10</bucket-size>\r\n    <max-concurrent-requests>5</max-concurrent-requests>\r\n    <retry-parameters>\r\n        <task-age-limit>3h</task-age-limit>\r\n        <min-backoff-seconds>10</min-backoff-seconds>\r\n        <max-backoff-seconds>600</max-backoff-seconds>\r\n        <max-doublings>5</max-doublings>\r\n    </retry-parameters>\r\n    <target>apns</target>\r\n  </queue>\r\n\r\n  [...]\r\n\r\n</queue-entries>\r\n\r\n```\r\n\r\nAlways place the queue.xml file in the `default` module to save yourself from troubles; even though the target is not the `default` module.\r\n\r\nA few things to note here:\r\n\r\n1. We named our push queue `apns` (same name as our module but it can be anything).\r\n2. We set `max-concurrent-requests` to `5`; it makes sense to set this to a value same as the capacity of our connection pool (see below).\r\n3. We set `target` to `apns`; tasks will be executed in our `apns` module.\r\n\r\n#### Task definition\r\n\r\nThis is the most interesting part. This is how a task that we put into the queue is defined:\r\n\r\n```java\r\npublic class SendPushNotificationToApnsTask implements DeferredTask {\r\n\r\n  private static final long serialVersionUID = 1L;\r\n\r\n  private static volatile ApnsConnectionFactory sApnsConnectionFactory;\r\n  private static volatile ApnsConnectionPool sApnsConnectionPool;\r\n  private static volatile PushNotificationService sPushNotificationService;\r\n  private static final int APNS_CONNECTION_POOL_CAPACITY = 5;\r\n\r\n  private final PushNotification mPushNotification;\r\n\r\n  public SendPushNotificationToApnsTask(PushNotification pushNotification) {\r\n    mPushNotification = pushNotification;\r\n  }\r\n\r\n  @Override\r\n  public void run() {\r\n    try {\r\n      trySendingPushNotification();\r\n    } catch (CannotOpenConnectionException e) {\r\n      throw new RuntimeException(\"Could not connect to APNS\", e);\r\n    } catch (CannotUseConnectionException e) {\r\n       throw new RuntimeException(\"Could not send: \" + mPushNotification, e);\r\n    } catch (PayloadException e) {\r\n        getLogger().error(\"Could not send push notification (dropping task)\", e);\r\n    }\r\n  }\r\n\r\n  private void trySendingPushNotification() throws CannotOpenConnectionException, CannotUseConnectionException, PayloadException {\r\n    ApnsConnection apnsConnection = getApnsConnectionPool().obtain();\r\n    if (apnsConnection == null) {\r\n      apnsConnection = openConnection();\r\n    }\r\n    \r\n    try {\r\n      getLogger().debug(\"Sending push notification: {}\", mPushNotification);\r\n      getPushNotificationService().send(mPushNotification, apnsConnection);\r\n      getApnsConnectionPool().put(apnsConnection);\r\n    } catch (CannotUseConnectionException e) {\r\n      getLogger().debug(\"Could not send push notification - opening new connection\");\r\n      apnsConnection = openConnection();\r\n      getLogger().debug(\"Retrying sending push notification\");\r\n      getPushNotificationService().send(mPushNotification, apnsConnection);\r\n      getApnsConnectionPool().put(apnsConnection);\r\n    }\r\n  }\r\n\r\n  private static ApnsConnectionPool getApnsConnectionPool() {\r\n    if (sApnsConnectionPool == null) {\r\n      synchronized (SendPushNotificationToApnsTask.class) {\r\n        if (sApnsConnectionPool == null) {\r\n          sApnsConnectionPool = new ApnsConnectionPool(APNS_CONNECTION_POOL_CAPACITY);\r\n        }        \r\n      }\r\n    }  \r\n    return sApnsConnectionPool;\r\n  }\r\n\r\n  private static PushNotificationService getPushNotificationService() {\r\n    if (sPushNotificationService == null) {\r\n      synchronized (SendPushNotificationToApnsTask.class) {\r\n        if (sPushNotificationService == null) {\r\n          sPushNotificationService = new DefaultPushNotificationService();\r\n        }        \r\n      }\r\n    }  \r\n    return sPushNotificationService;\r\n  }\r\n\r\n  private static ApnsConnection openConnection() throws CannotOpenConnectionException {\r\n    getLogger().debug(\"Connecting to APNS\");\r\n    return getApnsConnectionFactory().openPushConnection();\r\n  }  \r\n\r\n  private static ApnsConnectionFactory getApnsConnectionFactory() {\r\n    if (sApnsConnectionFactory == null) {\r\n      synchronized (SendPushNotificationToApnsTask.class) {\r\n        if (sApnsConnectionFactory == null) {\r\n          DefaultApnsConnectionFactory.Builder builder = DefaultApnsConnectionFactory.Builder.get();\r\n          KeyStoreProvider ksp = new ClassPathResourceKeyStoreProvider(PATH_TO_KEYSTORE, KeyStoreType.PKCS12, KEYSTORE_PWD);\r\n          builder.setSandboxKeyStoreProvider(ksp);        \r\n          try {\r\n            sApnsConnectionFactory = builder.build();\r\n          } catch (ApnsException e) {\r\n            throw new ApnsRuntimeException(\"Could not create APNS connection factory\", e);\r\n          }\r\n      }\r\n    }  \r\n    return sApnsConnectionFactory;\r\n  }\r\n\r\n  private org.slf4j.Logger getLogger() {\r\n    [...]\r\n  }\r\n}\r\n\r\n\r\n```\r\nThis task is executed in the `apns` module. \r\n\r\nOur connection pool has a capacity same as `max-concurrent-requests` in our queue.xml.\r\n\r\nClass `PushNotification` implements `Serializable` so you can simply pass a push notification instance to the task's constructor and save it in an instance field.\r\n\r\nVery important, that you set a `serialVersionUID` because if you don't it gets autogenerated for you and you might end up having a different version uid even though you didn't make any incomaptible changes to the class. If `serialVersionUID` changes then you won't be able to process old tasks still remaining in the queue with old uid (because deserialization will fail).\r\n\r\nNote, that every time a runtime exception escapes the `run()` method our task is considered as failed and will be retried by App Engine later (based on `retry-parameters` in queue.xml). \r\n\r\nYou'll get a `PayloadException` if the payload is larger than 256 bytes. Note that we don't throw a runtime exception in this case to avoid the hot-potato anti-pattern (payload will be still too large the next time we retry).\r\n\r\nWe create static members lazily because we don't want them to be created when we're just enqueuing a task.\r\n\r\n\r\n#### Enqueuing tasks\r\n\r\n```java\r\nPushNotification pn = ...; // create one\r\nDeferredTask task = new SendPushNotificationToApnsTask(pn);\r\nQueueFactory.getQueue(\"apns\").add(TaskOptions.Builder.withPayload(task));\r\n```\r\n\r\nYou can enqueue the task from any module.\r\n\r\n#### Epilogue\r\n\r\nIn our example we assumed that each push notification is sent to one specific user with at most a couple of devices. If you want to send a single push notification to thousands of devices you could quickly run into problems. In this case you may want to check out a [more sophisticated example](http://googlecloudplatform.blogspot.hu/2013/07/google-app-engine-takes-pain-out-of-sending-ios-push-notifications.html) with pull queues and query cursors from Google.\r\n\r\nIn case you find something that is not working as expected please report it in the [issue tracker](https://github.com/ZsoltSafrany/java-apns-gae/issues).\r\n\r\nWe use this library in our own projects thus you can expect that it will remain maintained.\r\n\r\n# Download\r\n\r\n<p><a href=\"http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.zsoltsafrany&a=java-apns-gae&v=LATEST\">&darr; <span class=\"version-tag\">Latest</span> JAR</a></p>\r\n\r\nThe source code of the library is [available on GitHub](https://github.com/ZsoltSafrany/java-apns-gae).\r\n\r\n## Maven\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>com.zsoltsafrany</groupId>\r\n  <artifactId>java-apns-gae</artifactId>\r\n  <version>1.1.0</version>\r\n</dependency>\r\n```\r\n\r\n## Gradle\r\n\r\n```Groovy\r\ncompile 'com.zsoltsafrany:java-apns-gae:1.1.0'\r\n```\r\n\r\n# License\r\n```HTML\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014 Zsolt Safrany\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n```","google":"UA-53950173-2","note":"Don't delete this file! It's used internally to help with page regeneration."}